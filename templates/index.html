<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Dictation Engine</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&family=JetBrains+Mono:wght@500&display=swap" rel="stylesheet">

    <style>
        body { background: #0f172a; color: white; font-family: 'Inter', sans-serif; overflow: hidden; }
        .mono { font-family: 'JetBrains Mono', monospace; }

        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }

        .pulse-active { animation: pulse 1.5s infinite; background: #ef4444 !important; border-color: #ef4444 !important; }
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 15px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        #finalBox {
            white-space: normal !important;
            line-height: 1.65;
            padding-bottom: 60px;
        }

        #rawBox p { white-space: pre-wrap; }

        ul { 
            list-style: disc !important;
            margin-left: 25px !important;
            padding-left: 10px !important;
        }

        .fade-in { animation: fadeIn 0.3s forwards; opacity: 0; transform: translateY(5px); }
        @keyframes fadeIn { to { opacity: 1; transform: translateY(0); } }
    </style>
</head>

<body class="h-screen flex">

    <!-- SIDEBAR -->
    <div class="w-64 bg-slate-900 border-r border-slate-700 flex flex-col shrink-0">
        <div class="p-4 border-b border-slate-700 text-xs font-bold tracking-widest text-slate-500">SESSION HISTORY</div>
        <div id="historyList" class="flex-1 overflow-y-auto p-2 space-y-2"></div>
    </div>

    <!-- MAIN AREA -->
    <div class="flex-1 flex flex-col h-screen">

        <!-- TOP BAR -->
        <div class="h-16 bg-slate-900 border-b border-slate-700 flex items-center justify-between px-6">
            <h1 class="font-bold text-xl text-transparent bg-clip-text bg-gradient-to-r from-cyan-400 to-blue-500">
                Dictation Engine
            </h1>

            <div class="flex items-center gap-4">
                <div class="flex items-center gap-2">
                    <span id="statusDot" class="w-2 h-2 rounded-full bg-slate-500"></span>
                    <span id="statusText" class="text-xs mono text-slate-400">IDLE</span>
                </div>

                <select id="toneSelect" class="bg-slate-800 text-sm border border-slate-600 rounded px-3 py-1 outline-none">
                    <option value="neutral">Neutral</option>
                    <option value="formal">Formal</option>
                </select>
            </div>
        </div>

        <!-- PANELS -->
        <div class="flex-1 flex overflow-hidden">

            <!-- RAW INPUT PANEL -->
            <div class="w-1/2 bg-slate-800/50 flex flex-col border-r border-slate-700">
                <div class="p-2 bg-slate-800/80 border-b border-slate-700 text-[10px] font-bold text-slate-500 uppercase">
                    Raw Input
                </div>

                <div id="rawBox" class="flex-1 p-6 overflow-y-auto font-mono text-sm text-slate-400 space-y-3"></div>
            </div>

            <!-- FINAL OUTPUT PANEL -->
            <div class="w-1/2 bg-slate-900 flex flex-col relative">
                <div class="p-2 bg-slate-800 border-b border-slate-700 flex justify-between items-center">
                    <span class="text-[10px] font-bold text-green-500 uppercase">Final Output</span>
                    <button onclick="copyFinal()" class="text-[10px] font-bold text-blue-400 hover:text-white">COPY</button>
                </div>

                <div id="finalBox" class="flex-1 p-6 overflow-y-auto text-lg text-slate-100"></div>

                <!-- METRICS -->
                <div class="absolute bottom-0 w-full bg-slate-800/90 border-t border-slate-700 p-1 flex justify-around text-[10px] mono text-slate-400">
                    <span>ASR: <b id="l_asr" class="text-white">0</b></span>
                    <span>GRAM: <b id="l_gram" class="text-white">0</b></span>
                    <span>FMT: <b id="l_logic" class="text-white">0</b></span>
                    <span>TOT: <b id="l_tot" class="text-cyan-400">0</b>ms</span>
                </div>
            </div>
        </div>

        <!-- MICROPHONE -->
        <div class="h-24 bg-slate-900 border-t border-slate-700 flex items-center justify-center relative">
            <div class="absolute bottom-0 left-0 h-1 bg-slate-700 w-full">
                <div id="volBar" class="h-full bg-cyan-500 transition-all duration-75" style="width: 0%"></div>
                <div class="absolute bottom-0 h-2 w-0.5 bg-red-500 z-10" style="left: 2%"></div>
            </div>

            <button id="micBtn" onclick="toggleSession()"
                class="w-16 h-16 rounded-full bg-slate-700 border-2 border-slate-500 text-white hover:bg-slate-600 shadow-xl flex items-center justify-center transition">

                <svg class="w-8 h-8" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                        d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
                </svg>
            </button>
        </div>
    </div>

    <!-- ===================== PART 1 JS (Audio + UI Logic) ===================== -->
    <script>
        const SILENCE_MS = 1000;
        const VOL_THRESHOLD = 2;

        let audioCtx, analyser, micSrc, scriptNode, mediaRecorder;
        let audioChunks = [], isSessionActive = false, isSpeaking = false;
        let silenceStart = Date.now(), sessionText = "";

        function toggleSession() { isSessionActive ? stopSession() : startSession(); }

        async function startSession() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });

                isSessionActive = true;
                sessionText = "";

                rawBox.innerHTML = "";
                finalBox.innerHTML = "";

                micBtn.classList.add("pulse-active");
                setStatus("LISTENING", "text-cyan-400", "bg-cyan-500");

                audioCtx = new AudioContext();
                await audioCtx.resume();

                analyser = audioCtx.createAnalyser();
                micSrc = audioCtx.createMediaStreamSource(stream);
                scriptNode = audioCtx.createScriptProcessor(2048, 1, 1);

                micSrc.connect(analyser);
                analyser.connect(scriptNode);
                scriptNode.connect(audioCtx.destination);

                setupRecorder(stream);

                scriptNode.onaudioprocess = () => {
                    const arr = new Uint8Array(analyser.frequencyBinCount);
                    analyser.getByteFrequencyData(arr);

                    const avg = arr.reduce((a,b)=>a+b)/arr.length;
                    volBar.style.width = Math.min(100, avg*2) + "%";

                    if (avg > VOL_THRESHOLD) {
                        isSpeaking = true;
                        silenceStart = Date.now();
                        setStatus("SPEAKING", "text-green-400", "bg-green-500");
                    }
                    else if (isSpeaking) {
                        setStatus("WAITING...", "text-orange-400", "bg-orange-500");

                        if (Date.now() - silenceStart > SILENCE_MS) {
                            isSpeaking = false;
                            setStatus("PROCESSING", "text-yellow-400", "bg-yellow-500");

                            if (mediaRecorder.state === "recording") mediaRecorder.stop();
                        }
                    }
                    else {
                        if (isSessionActive) setStatus("LISTENING", "text-cyan-400", "bg-cyan-500");
                    }
                };

            } catch (e) {
                            }
        }

        function setupRecorder(stream) {
            mediaRecorder = new MediaRecorder(stream);

            mediaRecorder.ondataavailable = e => {
                if (e.data.size > 0) audioChunks.push(e.data);
            };

            mediaRecorder.onstop = () => {
                if (audioChunks.length > 0) {
                    const blob = new Blob(audioChunks, { type: "audio/webm" });
                    audioChunks = [];
                    sendData(blob);
                }
                if (isSessionActive) mediaRecorder.start();
            };

            mediaRecorder.start();
        }

        function stopSession() {
            if (audioCtx) audioCtx.close();
            if (mediaRecorder && mediaRecorder.state !== "inactive") mediaRecorder.stop();

            isSessionActive = false;

            micBtn.classList.remove("pulse-active");
            setStatus("IDLE", "text-slate-400", "bg-slate-500");

            volBar.style.width = "0%";

            if (sessionText.trim()) addToHistory(sessionText);
        }

        async function sendData(blob) {
            if (blob.size < 2000) return;

            const fd = new FormData();
            fd.append("file", blob);
            fd.append("tone", toneSelect.value);

            try {
                const res = await fetch("/process", { method: "POST", body: fd });
                const data = await res.json();

                if (data.status === "success") {

                    /* RAW INPUT */
                    let p = document.createElement("p");
                    p.className = "fade-in border-b border-slate-700 pb-2 text-[11px]";
                    p.innerText = data.raw;
                    rawBox.appendChild(p);
                    rawBox.scrollTop = rawBox.scrollHeight;

                    /* FINAL OUTPUT processed through formatter.js logic */
                    const formatted = autoFormatOutput(data.final);

                    finalBox.innerHTML += formatted + "<br>";
                    finalBox.scrollTop = finalBox.scrollHeight;

                    sessionText += formatted;

                    /* METRICS */
                    l_asr.innerText = data.metrics.asr;
                    l_gram.innerText = data.metrics.grammar;
                    l_logic.innerText = data.metrics.logic;
                    l_tot.innerText = data.metrics.total;
                }

            } catch (e) {
                console.error(e);
            }
        }

        function setStatus(text, color, dot) {
            statusText.innerText = text;
            statusText.className = `text-xs mono ${color}`;
            statusDot.className = `w-2 h-2 rounded-full ${dot}`;
        }

        function addToHistory(text) {
            let div = document.createElement("div");
            div.className = "bg-slate-800 p-2 rounded text-[10px] text-slate-300 truncate cursor-pointer hover:bg-slate-700 mb-2";
            div.innerText = text.replace(/<[^>]+>/g, "").substring(0,40) + "...";
            div.onclick = () => finalBox.innerHTML = text;
            historyList.prepend(div);
        }

        function copyFinal() {
            navigator.clipboard.writeText(finalBox.innerText);
        }
    </script>


    <!-- ************************************************************
         FILE 2 — formatter.js SECTION
         ✔ Checklist Formatter
         ✔ Email Formatter
         ✔ Unified AutoFormatter
    ************************************************************** -->
    <script>

        /* ============================================================
           ✔ CLEANER CHECKLIST FORMATTER
        ============================================================ */
        function formatChecklist(text) {
            let lower = text.toLowerCase();

            if (!lower.includes("checklist")) return null;

            let itemsText = text;

            if (lower.includes("checklist of"))
                itemsText = text.split(/checklist of/i)[1];
            else if (lower.includes("checklist:"))
                itemsText = text.split(/checklist:/i)[1];

            let items = itemsText
                .split(",")
                .map(i => i.trim().replace(/\.$/, ""))
                .filter(i => i.length > 0);

            if (items.length <= 1) return null;

            let html = `<p><b>Here is the checklist:</b></p><ul>`;
            items.forEach(item => html += `<li>${item.charAt(0).toUpperCase() + item.slice(1)}</li>`);
            html += `</ul>`;

            return html;
        }


        /* ============================================================
           ✔ **SUPER CLEAN EMAIL FORMATTER**
        ============================================================ */
        function formatEmail(text) {
            let lower = text.toLowerCase();

            // Detect if user is dictating an email
            if (
                !lower.includes("draft an email") &&
                !lower.includes("write an email") &&
                !lower.includes("email to") &&
                !lower.includes("send an email")
            ) return null;

            /*----- Extract Name -----*/
            let nameMatch =
                text.match(/email to ([A-Za-z]+)/i) ||
                text.match(/to ([A-Za-z]+) subject/i) ||
                text.match(/write an email to ([A-Za-z]+)/i);

            let name = nameMatch ? nameMatch[1] : "Recipient";

            /*----- Extract Subject -----*/
            let subject = "";
            if (lower.includes("subject")) {
                subject = text.split(/subject/i)[1]
                    .split(/[.]/)[0]
                    .replace(/[:,]/g, "")
                    .trim();
            }

            if (!subject) subject = "No subject";

            /*----- Extract Email Body -----*/
            let body = "";
            if (lower.includes("subject")) {
                body = text.split(/subject/i)[1]
                    .split(/[.]/)
                    .slice(1)
                    .join(". ")
                    .trim();
            } else {
                body = text;
            }

            // Remove email boilerplate commands
            body = body
                .replace(/(write|draft|send) an email.*?\./i, "")
                .replace(/best regards.*/i, "")
                .replace(/dear [A-Za-z]+/i, "")
                .trim();

            /*----- Extract Sender Name -----*/
            let senderMatch = text.match(/best regards\s*([A-Za-z]+)/i);
            let sender = senderMatch ? senderMatch[1] : "";

            /*----- Build Final Clean HTML Email -----*/
            return `
                <p><b>Subject: ${subject.charAt(0).toUpperCase() + subject.slice(1)}</b></p>

                <p>Dear ${name},</p>

                <p>${body.charAt(0).toUpperCase() + body.slice(1)}.</p>

                <p>Best regards,<br>${sender}</p>
            `;
        }


        /* ============================================================
           ✔ Universal Auto Formatter (router)
        ============================================================ */
        function autoFormatOutput(text) {

            // Try checklist first
            const c = formatChecklist(text);
            if (c) return c;

            // Try email formatting
            const e = formatEmail(text);
            if (e) return e;

            // Default fallback
            return `<p>${text}</p>`;
        }

    </script>

</body>
</html>
